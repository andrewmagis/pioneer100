
# System imports
from datetime import date, datetime, timedelta as td
import logging

import fitbit
from p100.errors import MyError

import numpy as np
import scipy
import math, re
import pandas, pandas.io

# Codebase imports
from p100.errors import MyError

logger = logging.getLogger("p100.microbiome")

class Microbiome(object):
    tax = ['kingdom', 'phylum', 'class', 'order', 'family', 'genus', 'species']
    def __init__(self, database):
        logger.debug("Creating a Microbiome object")
        self.database = database

    def GetData(self, username=None, rnd=None, agg_to='species',
            perc=True):
        """
        Returns a dataframe with the microbiomic data for
        a given user and round(if provided) aggregated to the agg_to
        level.  If perc is true, the it returns the aggregated
        percentages, otherwise the counts.
        """
        logger.debug("GetData( %s, %s, %s, %s  )" %( username, rnd,  agg_to, perc))
        cut = self.tax.index(agg_to) + 1
        #the trimmed list of taxonomies
        tr_tax = self.tax[:cut]
        #this part puts together the bits needed to get the taxonomic
        #SELECT .
        select_stmt = ['%s.tax_label AS `%s`' % (t[:3], t) for t in tr_tax]#labels
        select_stmt += ['tx.`%s` as %s_id' % (t,t) for t in tr_tax]#ids
        select_stmt += [ 'obs.observation_id', 'obs.username', 'obs.round' ]
        if perc:
            select_stmt += ["SUM(lvl.percentage) as value"]
        else:
            select_stmt += ["SUM(lvl.read_counts) as value"]
        #FROM
        from_stmt = ['mb_taxonomy_labels %s' % (t[:3],) for t in tr_tax]
        from_stmt += ['mb_observation obs', 'mb_taxonomy tx', 'mb_levels lvl']
        #WHERE
        where_stmt =  ['%s.tax_level = "%s"' %  (t[:3], t) for t in tr_tax]
        where_stmt += ['%s.tax_label_id = tx.%s' %  (t[:3], t) for t in tr_tax]
        where_stmt += ['obs.observation_id = lvl.observation_id', 
                       'tx.taxonomy_id = lvl.taxonomy_id', 'lvl.read_counts > 0']
        #GROUP
        group_stmt = [ "obs.observation_id" ] + ['%s_id' % t for  t in tr_tax]

        #variables
        if username and rnd:
            where_stmt +=  ["obs.round = %s","obs.username = %s"]
            var_tup = (rnd, username)
        elif username:
            where_stmt +=  ["obs.username = %s"]
            var_tup = ( username)
        elif rnd:
            where_stmt +=  ["obs.round = %s"]
            var_tup = (rnd, )
        else:
            var_tup = None

        statements = (', '.join( select_stmt ), ', '.join( from_stmt ), 
                ' and '.join( where_stmt ), ', '.join( group_stmt ) )

        q_string = """
        SELECT %s
        FROM %s
        WHERE %s
        GROUP BY %s
        """ % (', '.join( select_stmt ), ', '.join( from_stmt ), 
                ' and '.join( where_stmt ), ', '.join( group_stmt ) )

        res = self.database.GetDataFrame(q_string, var_tup)
        #reorder the columns, they get messy
        column_order = ['observation_id', 'username', 'round']
        column_order += tr_tax 
        column_order += ["%s_id" % x for x in tr_tax]
        column_order += ['value']
        column_order += [x for x in res.columns if x not in column_order]
        return res[column_order]

    def get_taxonomy_names(self, up_to=None):
        if up_to:
            return self.tax[:(self.tax.index(up_to) + 1)]
        else:
            return self.tax

    def username_vectors( self, dataframe):
        """
        Given a dataframe as generated by GetData,
            return a new dataframe where the index
            is a string representation of the full path to the
            taxa and the column name is the username,
            or username-round in the case of multiple rounds
        """
        utax =  [x for x in self.tax if x in dataframe.columns]
        unames = dataframe.username.unique()
        rnds = dataframe['round'].unique()

        result = {}
        for uname in unames:
            for rnd in rnds:
                udf = dataframe[(dataframe.username == uname) &
                        (dataframe['round'] == rnd)]
                if len(udf.index)>0:
                    d = udf[utax + ['value']].to_dict(orient="split")['data']
                    if len(rnds) > 1:
                        key = "%s-%i" % (uname, rnd)
                    else:
                        key = uname
                    result[key] = {}
                    for row in d:
                        trimmed = [a[:3] for a in row[:-2]] + row[-2:-1]
                        sub_key = '>'.join( trimmed )
                        result[key][sub_key] =  row[-1]
        return pandas.DataFrame.from_dict( result )
