
# System imports
from datetime import date, datetime, timedelta as td
import logging

import fitbit
from p100.errors import MyError

import numpy as np
import scipy
import math, re
import pandas, pandas.io
from ete2 import Tree

# Codebase imports
from p100.errors import MyError
import time

l_logger = logging.getLogger("p100.microbiome")

class Microbiome(object):
    tax = ['kingdom', 'phylum', 'class', 'order', 'family', 'genus', 'species']
    def __init__(self, database):
        l_logger.debug("Creating a Microbiome object")
        self.database = database

    def GetData(self,username=None, rnd=None, agg_to='species',
            perc=True, observation_id=None):
        """
        Returns a dataframe with the microbiomic data for
        a given user and round(if provided) aggregated to the agg_to
        level.  If perc is true, the it returns the aggregated
        percentages, otherwise the counts.
        """

        l_logger.debug("GetData( %s, %s, %s, %s  )" %( username, rnd,  agg_to, perc))
        cut = self.tax.index(agg_to) + 1
        #the trimmed list of taxonomies
        tr_tax = self.tax[:cut]
        #this part puts together the bits needed to get the taxonomic
        #SELECT .
        select_stmt = ['%s.tax_label AS `%s`' % (t[:3], t) for t in tr_tax]#labels
        select_stmt += ['tx.`%s` as %s_id' % (t,t) for t in tr_tax]#ids
        select_stmt += [ 'obs.observation_id', 'obs.username', 'obs.round' ]
        if perc:
            select_stmt += ["SUM(lvl.percentage) as value"]
        else:
            select_stmt += ["SUM(lvl.read_counts) as value"]
        #FROM
        from_stmt = ['mb_taxonomy_labels %s' % (t[:3],) for t in tr_tax]
        from_stmt += ['mb_observation obs', 'mb_taxonomy tx', 'mb_levels lvl']
        #WHERE
        where_stmt =  ['%s.tax_level = "%s"' %  (t[:3], t) for t in tr_tax]
        where_stmt += ['%s.tax_label_id = tx.%s' %  (t[:3], t) for t in tr_tax]
        where_stmt += ['obs.observation_id = lvl.observation_id', 
                       'tx.taxonomy_id = lvl.taxonomy_id', 'lvl.read_counts > 0']
        #GROUP
        group_stmt = [ "obs.observation_id" ] + ['%s_id' % t for  t in tr_tax]

        #variables
        var_list = []

        if observation_id:
            where_stmt +=  ["obs.observation_id"]
            var_list += [int(observation_id)]
        if username:
            where_stmt +=  ["obs.username = %s"]
            var_list += [str(int(username))]
        if rnd:
            where_stmt +=  ["obs.round = %s"]
            var_list += [int(rnd)]
        var_tup = tuple( var_list )

        statements = (', '.join( select_stmt ), ', '.join( from_stmt ), 
                ' and '.join( where_stmt ), ', '.join( group_stmt ) )

        q_string = """
        SELECT %s
        FROM %s
        WHERE %s
        GROUP BY %s
        """ % (', '.join( select_stmt ), ', '.join( from_stmt ), 
                ' and '.join( where_stmt ), ', '.join( group_stmt ) )

        res = self.database.GetDataFrame(q_string, var_tup)
        #reorder the columns, they get messy
        column_order = ['observation_id', 'username', 'round']
        column_order += tr_tax 
        column_order += ["%s_id" % x for x in tr_tax]
        column_order += ['value']
        column_order += [x for x in res.columns if x not in column_order]
        return res[column_order]

    def get_taxonomy_names(self, up_to=None):
        if up_to:
            return self.tax[:(self.tax.index(up_to) + 1)]
        else:
            return self.tax

    def username_vectors( self, dataframe):
        """
        Given a dataframe as generated by GetData,
            return a new dataframe where the index
            is a string representation of the full path to the
            taxa and the column name is the username,
            or username-round in the case of multiple rounds
        """
        utax =  [x for x in self.tax if x in dataframe.columns]
        unames = dataframe.username.unique()
        rnds = dataframe['round'].unique()

        result = {}
        for uname in unames:
            for rnd in rnds:
                udf = dataframe[(dataframe.username == uname) &
                        (dataframe['round'] == rnd)]
                if len(udf.index)>0:
                    d = udf[utax + ['value']].to_dict(orient="split")['data']
                    if len(rnds) > 1:
                        key = "%s-%i" % (uname, rnd)
                    else:
                        key = uname
                    result[key] = {}
                    for row in d:
                        trimmed = [a[:3] for a in row[:-2]] + row[-2:-1]
                        sub_key = '>'.join( trimmed )
                        result[key][sub_key] =  row[-1]
        return pandas.DataFrame.from_dict( result )

    def get_unifrac_matrix( self, observation_ids, tree_file, weighted =
            True):
        q_string = """
            SELECT tx.OTU, lvl.observation_id, lvl.percentage
            FROM mb_taxonomy tx, mb_levels lvl
            WHERE tx.taxonomy_id = lvl.taxonomy_id
            and lvl.observation_id in (%s)
            and lvl.percentage > 0
            ORDER BY lvl.observation_id
        """
        q_string = q_string % (', '.join(['%s' for x in observation_ids]))
        df_source = self.database.GetDataFrame( q_string, tuple( map(int, observation_ids) ) )
        otus = df_source.OTU.unique()
        l_logger.debug( otus )
        tree = self._load_tree( tree_file )
        return ( df_source, tree)
        def gt():
            from time import gmtime, strftime
            return strftime("%a, %d %b %Y %H:%M:%S +0000", gmtime())
        l_logger.debug( "pruning [%s]" % (  gt(),) )
        new_tree = tree.prune( map(str,otus) )
        l_logger.debug("done pruning [%s]" % (  gt(),))

        return #dataframe containing distances

    def _load_tree( self, tree_file ):
        """
        Given a path to a tree in nvformat, return the tree
        """

        return Tree( tree_file )
